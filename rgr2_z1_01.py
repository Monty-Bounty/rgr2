import math

# Задача 1: Комбинированный метод хорд и касательных
# Уравнение: x^3 - 12x + 10 = 0
# Точность: 0.001

# Определяем функцию и ее производные
def f(x):
    return x**3 - 12*x + 10

def f_prime(x): # Первая производная
    return 3*x**2 - 12

def f_double_prime(x): # Вторая производная
    return 6*x

# Комбинированный метод хорд и касательных
def combined_method(a, b, epsilon):
    """
    Реализация комбинированного метода хорд и касательных.
    a, b: границы интервала
    epsilon: требуемая точность
    """
    print(f"\nПоиск корня на интервале [{a}, {b}]")
    
    # Проверяем условие знака f(x) * f''(x) на концах интервала
    # f_double_prime(x) = 6x.
    # Если f(a) * f''(x) > 0 на [a,b], то используем случай (а) из Приложения 1
    # Если f(b) * f''(x) > 0 на [a,b], то используем случай (б) из Приложения 1

    # Определяем, какой случай использовать (а или б)
    # Для этого нужно, чтобы f''(x) сохраняла знак на интервале.
    # Если f''(x) меняет знак (т.е. 0 находится внутри интервала для f''),
    # то метод в такой форме может быть неприменим напрямую или интервал нужно делить.
    # В нашем случае f''(x) = 6x, знак меняется в x=0.

    # Для интервалов, не содержащих x=0, f''(x) знак сохраняет.
    # Если интервал содержит 0, нужно быть осторожнее или разбить интервал.

    x_n = 0
    xt_n = 0 
    iterations = 0

    # Для случая (а): f(a) * f''(x) > 0
    # x_0 = a, xt_0 = b
    # x_{n+1} = x_n - f(x_n) / f'(x_n)  (метод Ньютона)
    # xt_{n+1} = x_n - (f(x_n) * (xt_n - x_n)) / (f(xt_n) - f(x_n)) (метод хорд/секущих)
    
    # Для случая (б): f(b) * f''(x) > 0
    # x_0 = a, xt_0 = b
    # x_{n+1} = x_n - (f(x_n) * (xt_n - x_n)) / (f(xt_n) - f(x_n)) (метод хорд/секущих)
    # xt_{n+1} = xt_n - f(xt_n) / f'(xt_n) (метод Ньютона)

    current_f_double_prime_at_a = f_double_prime(a) # Оцениваем знак f''(x) по знаку на концах
    current_f_double_prime_at_b = f_double_prime(b)

    # Убедимся, что f(a) и f(b) имеют разные знаки
    if f(a) * f(b) >= 0:
        print(f"Ошибка: Значения функции на концах интервала [{a}, {b}] одного знака или один из них ноль.")
        print(f"f({a}) = {f(a)}, f({b}) = {f(b)}")
        return None

    # Определяем, какой случай использовать (а или б) из Приложения 1
    # Это зависит от знака f(endpoint) * f''(x)
    # Мы должны выбрать такой endpoint, чтобы f(endpoint) и f''(x) имели одинаковый знак на интервале.
    
    # Предположим, f''(x) не меняет знак на [a,b]. Возьмем f''( (a+b)/2 ) как представителя знака f''(x)
    f_double_prime_sign_in_interval = f_double_prime((a + b) / 2.0)

    use_case_a = False
    if f_double_prime_sign_in_interval == 0: # f''(x) = 0 в середине интервала, например, для f''(x)=6x интервал [-1,1]
        # Этот случай требует более детального анализа или выбора другого интервала
        # Для простоты, если f''(x) = 0 где-то, метод может работать некорректно с этими условиями.
        # Однако, если f''(x) = 0 на одном из концов, это тоже нужно учесть.
        # Если f_double_prime(a) != 0, то f(a) * f_double_prime(a) > 0
        if f_double_prime(a) != 0 and (f(a) * f_double_prime(a) > 0):
             use_case_a = True
        # Если f_double_prime(b) != 0, то f(b) * f_double_prime(b) > 0
        elif f_double_prime(b) != 0 and (f(b) * f_double_prime(b) > 0):
             use_case_a = False # Это будет случай (б)
        else:
            print(f"Не удалось определить случай для интервала [{a}, {b}] из-за поведения f''(x).")
            return None
    elif f(a) * f_double_prime_sign_in_interval > 0:
        use_case_a = True
    elif f(b) * f_double_prime_sign_in_interval > 0:
        use_case_a = False # Это случай (б)
    else:
        # Это может произойти, если f''(x) меняет знак или условия не выполняются
        # Например, f(a) и f(b) имеют разные знаки с f''(x)
        print(f"Не выполняются условия f(a)f''(x)>0 или f(b)f''(x)>0 для интервала [{a}, {b}].")
        print(f"f(a)={f(a)}, f(b)={f(b)}, f''((a+b)/2)={f_double_prime_sign_in_interval}")
        # Попробуем проверить условия из PDF более строго: f(a)*f''(x)>0 или f(b)*f''(x)>0 НА ВСЕМ ИНТЕРВАЛЕ
        # Это означает, что f''(x) должна быть одного знака на всем интервале.
        # И f(a) или f(b) должны иметь тот же знак.
        
        # Если f''(x) > 0 на [a,b]:
        #   Если f(a) > 0 -> случай (a)
        #   Если f(b) > 0 (и f(a) < 0) -> случай (б)
        # Если f''(x) < 0 на [a,b]:
        #   Если f(a) < 0 -> случай (a)
        #   Если f(b) < 0 (и f(a) > 0) -> случай (б)
        
        # Проверка знака f''(x) на интервале
        # Если a и b по разные стороны от 0 (для f''(x)=6x), то f''(x) меняет знак.
        if a * b < 0 and f_double_prime(0) == 0: # 0 - точка перегиба для 6x
             print(f"f''(x) меняет знак на интервале [{a}, {b}]. Метод может быть неточен.")
             # Тем не менее, попробуем применить, если условия на концах выполняются
        
        # Переопределяем use_case_a на основе знака f''(x) на концах интервала
        # Это упрощение, предполагая, что знак f''(x) постоянен или его поведение на концах показательно
        if f_double_prime(a) != 0 and f(a) * f_double_prime(a) > 0 : # f(a) и f''(a) одного знака
             # И если f_double_prime(a) того же знака что и f_double_prime(b) (или f_double_prime(b) == 0)
            if f_double_prime(a) * f_double_prime(b) >= 0:
                use_case_a = True
            else: # Знаки f''(a) и f''(b) разные - f''(x) меняет знак
                print(f"f''(x) меняет знак на интервале [{a}, {b}]. Выбираем стратегию по f(a) и f''(a).")
                use_case_a = True # Попытка
        elif f_double_prime(b) != 0 and f(b) * f_double_prime(b) > 0 : # f(b) и f''(b) одного знака
            if f_double_prime(a) * f_double_prime(b) >= 0:
                 use_case_a = False # Случай (б)
            else: # Знаки f''(a) и f''(b) разные - f''(x) меняет знак
                print(f"f''(x) меняет знак на интервале [{a}, {b}]. Выбираем стратегию по f(b) и f''(b).")
                use_case_a = False # Попытка (случай б)
        else:
            print(f"Не удалось строго определить случай (а) или (б) для интервала [{a}, {b}].")
            # Попробуем определить по знаку f''(x) в середине интервала, если он не ноль
            if f_double_prime_sign_in_interval != 0:
                if f(a) * f_double_prime_sign_in_interval > 0: use_case_a = True
                elif f(b) * f_double_prime_sign_in_interval > 0: use_case_a = False
                else: return None # Не удалось определить
            else: # f'' в середине 0
                 # Если f''(a) не 0 и f(a)f''(a)>0 -> случай а
                 if f_double_prime(a) !=0 and f(a)*f_double_prime(a) > 0: use_case_a = True
                 # Если f''(b) не 0 и f(b)f''(b)>0 -> случай б
                 elif f_double_prime(b) !=0 and f(b)*f_double_prime(b) > 0: use_case_a = False
                 else:
                    print("Невозможно применить метод: условия не выполняются.")
                    return None


    x_n = a
    xt_n = b
    
    print(f"Начальные значения: x_0 = {x_n}, xt_0 = {xt_n}")
    if use_case_a:
        print("Используется случай (а): Ньютон с x_n, Хорды с xt_n")
    else:
        print("Используется случай (б): Хорды с x_n, Ньютон с xt_n")

    while abs(xt_n - x_n) > epsilon:
        iterations += 1
        if iterations > 100: # Предохранитель от бесконечного цикла
            print("Превышено максимальное количество итераций.")
            return None

        fx_n = f(x_n)
        fxt_n = f(xt_n)

        # Проверка деления на ноль
        if use_case_a:
            f_prime_xn = f_prime(x_n)
            if f_prime_xn == 0:
                print(f"Ошибка: Производная f'({x_n}) равна нулю. Невозможно применить метод Ньютона.")
                return None
            if (fxt_n - fx_n) == 0:
                print(f"Ошибка: f(xt_n) - f(x_n) равно нулю. Невозможно применить метод хорд.")
                return None
            
            x_n_new = x_n - fx_n / f_prime_xn
            xt_n_new = x_n - (fx_n * (xt_n - x_n)) / (fxt_n - fx_n)
        else: # Случай (б)
            f_prime_xtn = f_prime(xt_n)
            if f_prime_xtn == 0:
                print(f"Ошибка: Производная f'({xt_n}) равна нулю. Невозможно применить метод Ньютона.")
                return None
            if (fxt_n - fx_n) == 0:
                print(f"Ошибка: f(xt_n) - f(x_n) равно нулю. Невозможно применить метод хорд.")
                return None

            x_n_new = x_n - (fx_n * (xt_n - x_n)) / (fxt_n - fx_n)
            xt_n_new = xt_n - fxt_n / f_prime_xtn
        
        x_n = x_n_new
        xt_n = xt_n_new

        # print(f"Итерация {iterations}: x_n = {x_n:.6f}, xt_n = {xt_n:.6f}, |xt_n - x_n| = {abs(xt_n - x_n):.6f}")

    root = (x_n + xt_n) / 2
    print(f"Корень найден: {root:.4f} после {iterations} итераций.")
    print(f"f({root:.4f}) = {f(root):.6f}")
    print(f"Интервал [{min(x_n, xt_n):.6f}, {max(x_n, xt_n):.6f}], ширина = {abs(xt_n - x_n):.6f}")
    return root

# Отделение корней (аналитически и иллюстративно)
print("Задача 1: Решение нелинейного уравнения x^3 - 12x + 10 = 0")
print("f(x) = x^3 - 12x + 10")
print("f'(x) = 3x^2 - 12")
print("f''(x) = 6x")
print("\nИллюстрация отделения корней (поиск интервалов знакопеременности):")
# Для иллюстрации можно показать значения функции в нескольких точках
# или упомянуть, что график строится для визуализации.
# f(-4) = -64 + 48 + 10 = -6
# f(-3) = -27 + 36 + 10 = 19  -> Корень между -4 и -3
# f(0) = 10
# f(1) = 1 - 12 + 10 = -1   -> Корень между 0 и 1
# f(2) = 8 - 24 + 10 = -6
# f(3) = 27 - 36 + 10 = 1   -> Корень между 2 и 3

print("f(-4) =", f(-4))
print("f(-3) =", f(-3)) # Корень в [-4, -3]
print("f(0) =", f(0))
print("f(1) =", f(1))   # Корень в [0, 1], точнее f(0.8)=0.912, f(0.9)=-0.071 => [0.8, 0.9]
print("f(0.8) =", f(0.8))
print("f(0.9) =", f(0.9))
print("f(2) =", f(2))
print("f(3) =", f(3))   # Корень в [2, 3]

# Графическая иллюстрация подразумевает построение графика функции y = f(x).
# На графике корни будут точками пересечения кривой с осью Ox.
# Аналитическое отделение корней уже произведено выше путем нахождения интервалов,
# на концах которых функция имеет разные знаки.

epsilon = 0.001

# Поиск корней на выделенных интервалах
# Интервал 1: [-4, -3]. f'' = 6x < 0. f(-4) = -6. f(-4)*f''(x) > 0 (т.к. -6 * отриц > 0). Случай (а). x0=-4, xt0=-3.
root1 = combined_method(-4, -3, epsilon)

# Интервал 2: [0.8, 0.9]. f'' = 6x > 0. f(0.8) = 0.912. f(0.8)*f''(x) > 0 (т.к. 0.912 * полож > 0). Случай (а). x0=0.8, xt0=0.9.
root2 = combined_method(0.8, 0.9, epsilon)

# Интервал 3: [2, 3]. f'' = 6x > 0. f(2) = -6. f(3) = 1.
# f(2)*f''(x) < 0. f(3)*f''(x) > 0 (т.к. 1 * полож > 0). Случай (б). x0=2, xt0=3.
root3 = combined_method(2, 3, epsilon)

print("\Найденные корни (с точностью до 0.001):")
if root1 is not None: print(f"Корень 1: {root1:.3f}")
if root2 is not None: print(f"Корень 2: {root2:.3f}")
if root3 is not None: print(f"Корень 3: {root3:.3f}")

# Примечание по "графической иллюстрации":
# В рамках простого Python-скрипта без библиотек построение графика затруднительно.
# Графическая иллюстрация заключается в построении графика функции y = x^3 - 12x + 10,
# на котором визуально определяются точки пересечения с осью Ox.
# Таблица значений функции, приведенная выше, демонстрирует смену знака функции,
# что указывает на наличие корней в соответствующих интервалах.
# f''(x) = 6x. Точка перегиба x=0.
# На (-inf, 0) функция выпукла (f'' < 0). На (0, +inf) функция вогнута (f'' > 0).
# Экстремумы: f'(x) = 3x^2 - 12 = 0 => x^2 = 4 => x = +/-2.
# f(2) = 8 - 24 + 10 = -6 (локальный минимум)
# f(-2) = -8 + 24 + 10 = 26 (локальный максимум)

'''
не имеет графического отображения. корни вычисляет и выводит норм
'''



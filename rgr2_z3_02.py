import math

# Задача 3: Усовершенствованный метод ломаных (метод Эйлера-Коши или Хейна)
# y' = 0.263 * (x^2 + cos(1.2*x)) + 0.453 * y
# Отрезок [0.2, 1.2], шаг dx = 0.1
# Начальное условие y(0.2) = 0.25
# Вывод в консоль с четырьмя десятичными знаками.

# Правая часть дифференциального уравнения dy/dx = f(x, y)
def diff_eq_func(x, y):
    return 0.263 * (x**2 + math.cos(1.2 * x)) + 0.453 * y

# Усовершенствованный метод ломаных
def improved_euler_method(f_func, x0, y0, h, x_end):
    """
    Решает ОДУ y'=f(x,y) усовершенствованным методом ломаных.
    f_func: функция f(x,y)
    x0, y0: начальные условия
    h: шаг
    x_end: конечная точка x
    Вычисления производятся с полной доступной точностью,
    округление до 4 знаков применяется только при выводе в консоль.
    """
    print(f"\nЗадача 3: Усовершенствованный метод ломаных")
    print(f"y' = 0.263(x^2 + cos(1.2x)) + 0.453y")
    print(f"x0 = {x0:.1f}, y0 = {y0:.4f}, h = {h:.1f}, x_end = {x_end:.1f}")
    print("----------------------------------------------------------------------------------------------------|")
    print("k  |   x_k   |    y_k    |  f(x_k,y_k) | x_k+1/2   |  y_k+1/2    | f(x_k+1/2,y_k+1/2)   |   y_k+1   |")
    print("----------------------------------------------------------------------------------------------------|")

    x_k = x0
    y_k = y0 # Начальное y без округления
    
    k_count = 0
    results = []
    results.append((k_count, x_k, y_k)) 

    # Цикл выполняется, пока x_k не достигнет или немного не превысит x_end
    # Чтобы гарантировать вычисление для x_end, условие x_k < x_end или x_k <= x_end - h/2 (примерно)
    # Более точное условие: пока x_k не превысит x_end - h + epsilon_for_float_comparison
    # Или просто итерировать определенное количество шагов
    num_steps = int((x_end - x0) / h + 0.5) # +0.5 для корректного округления при float-арифметике h

    for k_count_iter in range(num_steps): # Итерации от 0 до num_steps-1
        # Вычисляем f(x_k, y_k)
        f_xk_yk = f_func(x_k, y_k) 

        # Промежуточные значения
        x_k_half = x_k + h / 2.0
        
        # y_{k+1/2} = y_k + (h/2) * f(x_k, y_k)
        y_k_half = y_k + (h / 2.0) * f_xk_yk

        # Вычисляем f(x_{k+1/2}, y_{k+1/2})
        f_xk_half_yk_half = f_func(x_k_half, y_k_half)

        # Новое значение y_{k+1}
        # y_{k+1} = y_k + h * f(x_{k+1/2}, y_{k+1/2})
        y_k_plus_1 = y_k + h * f_xk_half_yk_half
        
        # Печать промежуточных значений для таблицы
        print(f"{k_count:2d} | {x_k:7.4f} | {y_k:9.4f} | {f_xk_yk:11.4f} |  {x_k_half:7.4f}  |  {y_k_half:9.4f}  |   {f_xk_half_yk_half:16.4f}   | {y_k_plus_1:9.4f} |")

        # Обновляем значения для следующей итерации
        x_k = x_k + h 
        y_k = y_k_plus_1
        k_count += 1
        results.append((k_count, x_k, y_k)) # Сохраняем результат текущего шага
            
    print("----------------------------------------------------------------------------------------------------|")
    return results

# Начальные параметры для Задачи 3
x_initial = 0.2
y_initial = 0.25
step_h = 0.1
x_final = 1.2 # Конечная точка x

solution_points = improved_euler_method(diff_eq_func, x_initial, y_initial, step_h, x_final)

print("\nИтоговые значения y(x):")
for point in solution_points:
    k_val, x_val, y_val = point
    print(f"k = {k_val:2d}, x = {x_val:.1f}, y = {y_val:.4f}")

